/* -----------------------------------------------------------------------------
 * This file was automatically generated by a Python script.
 * PLEASE DON'T EDIT IT DIRECTLY, your changes would be overwritten the next time the script is run.
 * Instead, go to "generator.py" and edit the "all_ways_of_finding_to_string" function there.
 * -----------------------------------------------------------------------------
 */

namespace internal {

template<typename T>
concept UseStd = requires(T value)
{
    {
        std::to_string(value)
        } -> std::convertible_to<std::string>;
};

template<typename T>
concept UseAdl = requires(T value)
{
    {
        to_string(value)
        } -> std::convertible_to<std::string>;
};

template<typename T>
concept UseMethod = requires(T value)
{
    {
        value.to_string()
        } -> std::convertible_to<std::string>;
};

template<typename T>
concept RangesImplementation = requires(T value)
{
    {
        internal::stringify__ranges<T>(value)
        } -> std::convertible_to<std::string>;
};

template<typename T>
concept OptionalLike = requires(T value)
{
    {
        value ? "Some: " + Cool::stringify(*value) : "None"
        } -> std::convertible_to<std::string>;
};

} // namespace internal

template<typename T>
auto stringify(const T& value) -> std::string
{
    if constexpr (internal::UseStd<T>)
    {
        return std::to_string(value);
    }
    else if constexpr (internal::UseAdl<T>)
    {
        return to_string(value);
    }
    else if constexpr (internal::UseMethod<T>)
    {
        return value.to_string();
    }
    else if constexpr (internal::RangesImplementation<T>)
    {
        return internal::stringify__ranges<T>(value);
    }
    else if constexpr (internal::OptionalLike<T>)
    {
        return value ? "Some: " + Cool::stringify(*value) : "None";
    }
    else
    {
        return std::string{"[Cool::stringify] ERROR: Couldn't find a to_string() function for this type: "} + typeid(T).name();
    }
}
